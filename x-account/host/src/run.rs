// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{COWBOY_EXAMPLE_APPS_ELF, COWBOY_EXAMPLE_APPS_ID};

use risc0_zkvm::Receipt;
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::Deserialize;
use std::fs;
use tlsn_core::presentation::{Presentation, PresentationOutput};
use tlsn_core::CryptoProvider;

use helpers::client::{get_core_proof_id, request_program_core_proof};

const BASE_PROVER_URL: &str = "http://localhost:1881";

#[derive(Debug, Deserialize)]
struct TlsnProofPartial {
    pub data: String,
}

pub async fn run(node_url: &str) {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let json_str = fs::read_to_string("x_proof.json").expect("Failed to read file");
    let tlsn_proof_parsed: TlsnProofPartial =
        serde_json::from_str(&json_str).expect("Invalid JSON");

    let url = format!("{}/prove", BASE_PROVER_URL);

    let core_receipt_response = request_program_core_proof(&url, &tlsn_proof_parsed.data, None)
        .await
        .unwrap();

    let core_receipt_bytes = hex::decode(core_receipt_response.receipt).unwrap();
    let core_receipt: Receipt = bincode::deserialize(&core_receipt_bytes).unwrap();

    let core_proof_id = get_core_proof_id(node_url).await.unwrap();
    println!("Core proof id set onchain curently is {:?} ", core_proof_id);

    let journal_value: [u8; 32] = core_receipt.journal.decode().expect(
        "Journal output should deserialize into the same types (& order) that it was written",
    );

    let tlsn_presentation_bytes = hex::decode(tlsn_proof_parsed.data).unwrap();
    let presentation: Presentation = bincode::deserialize(&tlsn_presentation_bytes).unwrap();

    let provider = CryptoProvider::default();

    let PresentationOutput {
        attestation,
        server_name,
        connection_info,
        transcript,
        ..
    } = presentation
        .clone()
        .verify(&provider)
        .expect("TLSN Presentation should verify");

    let mut partial_transcript = transcript.unwrap();
    // Set the unauthenticated bytes so they are distinguishable.
    partial_transcript.set_unauthed(b'X');

    let sent = String::from_utf8_lossy(partial_transcript.sent_unsafe());
    let recv = String::from_utf8_lossy(partial_transcript.received_unsafe());

    println!("Sent {:?}", sent);
    println!("Received {:?}", recv);

    let env = ExecutorEnv::builder()
        .add_assumption(core_receipt.clone())
        .write(&journal_value)
        .unwrap()
        .write(&tlsn_presentation_bytes)
        .unwrap()
        .write(&core_proof_id)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    println!("With journal value written {:?} ", journal_value);
    println!(
        "Proving program of our guest id: {:?} ",
        COWBOY_EXAMPLE_APPS_ID
    );

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, COWBOY_EXAMPLE_APPS_ELF).unwrap();

    // Extract the receipt, which contains the proof, and public outputs
    let receipt = prove_info.receipt;

    // Verify the proof
    receipt.verify(COWBOY_EXAMPLE_APPS_ID).unwrap();

    let proof_output: [u8; 32] = receipt
        .journal
        .decode()
        .expect("Journal should contain value");

    println!(
        "All verified. Committed(public) output is hash of usermane: 0x{:?} ",
        hex::encode(proof_output)
    );
}
